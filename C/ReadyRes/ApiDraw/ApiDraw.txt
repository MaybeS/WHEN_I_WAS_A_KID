이 텍스트 파일은 ApiDraw 과제의 실습 편의를 위해 제공되는 것입니다. 
직접 코드를 키보드로 입력해 보는 것이 좋으나 입력양이 많을 경우에는 
실습 시간이 오래 걸리므로 이 텍스트 파일에서 코드를 복사해서 붙이십시오.
실습 순서에 맞게 나열하되 입력하기에 다소 긴 코드만 수록했으며 단순한
변수 선언문이나 짧은 함수 호출문 등은 교제를 보고 직접 입력하십시오.

======================================
ApiDraw03
======================================


struct DObject
{
	DTool Type;
	RECT rt;
};
DObject **arObj;
int arSize;
int arNum;
int arGrowBy;





LRESULT OnCreate(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	NowTool=DT_LINE;
	DragMode=DM_NONE;
	arSize=100;
	arNum=0;
	arGrowBy=50;
	arObj=(DObject **)malloc(sizeof(DObject *)*arSize);
	return 0;
}



LRESULT OnDestroy(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	int idx;

	for (idx=0;idx<arNum;idx++) {
		free(arObj[idx]);
	}
	free(arObj);
	return 0;
}




// 일반 함수
BOOL AppendObject(DTool Type,int x1,int y1,int x2,int y2)
{
	if (Type == DT_LINE) {
		if (x1 == x2 && y1 == y2) {
			return FALSE;
		}
	} else {
		if (x1 == x2 || y1 == y2) {
			return FALSE;
		}
	}

	if (arNum >= arSize) {
		arSize+=arGrowBy;
		arObj=(DObject **)realloc(arObj,sizeof(DObject *)*arSize);
	}

	arObj[arNum]=(DObject *)malloc(sizeof(DObject));
	arObj[arNum]->Type=Type;
	SetRect(&arObj[arNum]->rt,x1,y1,x2,y2);
	arNum++;
	return TRUE;
}

BOOL AppendObject(DTool Type,RECT *prt)
{
	return AppendObject(Type,prt->left,prt->top,prt->right,prt->bottom);
}






LRESULT OnLButtonUp(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	if (DragMode==DM_DRAW) {
		AppendObject(NowTool,sx,sy,oldx,oldy);
		InvalidateRect(hWnd,NULL,TRUE);
	}
	DragMode=DM_NONE;
	ReleaseCapture();
	return 0;
}





LRESULT OnPaint(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	HDC hdc;
	PAINTSTRUCT ps;
	int idx;

	hdc=BeginPaint(hWnd, &ps);
	for (idx=0;idx<arNum;idx++) {
		switch (arObj[idx]->Type) {
		case DT_LINE:
			MoveToEx(hdc,arObj[idx]->rt.left,arObj[idx]->rt.top,NULL);
			LineTo(hdc,arObj[idx]->rt.right,arObj[idx]->rt.bottom);
			break;
		case DT_ELLIPSE:
			Ellipse(hdc,arObj[idx]->rt.left,arObj[idx]->rt.top,
				arObj[idx]->rt.right,arObj[idx]->rt.bottom);
			break;
		case DT_RECTANGLE:
			Rectangle(hdc,arObj[idx]->rt.left,arObj[idx]->rt.top,
				arObj[idx]->rt.right,arObj[idx]->rt.bottom);
			break;
		}
	}
	EndPaint(hWnd, &ps);
	return 0;
}


======================================
ApiDraw04
======================================



int FindObject(int x, int y)
{
	int idx;
	POINT pt;

	pt.x=x;
	pt.y=y;
	for (idx=arNum-1;idx>=0;idx--) {
		if (PtInRect(&arObj[idx]->rt,pt)==TRUE) {
			return idx;
		}
	}
	return -1;
}





LRESULT OnLButtonDown(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	int TempSel;

	if (NowTool==DT_SELECT) {
		TempSel=FindObject(LOWORD(lParam),HIWORD(lParam));
		if (NowSel != TempSel) {
			NowSel=TempSel;
			InvalidateRect(hWnd,NULL,TRUE);
			UpdateWindow(hWnd);
		}
	} else {
		sx=LOWORD(lParam);
		sy=HIWORD(lParam);
		oldx=sx;
		oldy=sy;
		DragMode=DM_DRAW;
	}
	SetCapture(hWnd);
	return 0;
}




LRESULT OnLButtonDown(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	int TempSel;

	if (NowTool==DT_SELECT) {
		TempSel=FindObject(LOWORD(lParam),HIWORD(lParam));
		if (NowSel != TempSel) {
			NowSel=TempSel;
			InvalidateRect(hWnd,NULL,TRUE);
			UpdateWindow(hWnd);
			TCHAR str[128];
			wsprintf(str,"NowSel=%d",NowSel);
			SetWindowText(GetParent(hWnd),str);
		}
	} else {


	
	

void DrawTracker(HDC hdc,int idx)
{
	RECT rt;
	int i;

	if (idx == -1) return;
	for (i=1;i<=8;i++) {
		GetTrackerRect(idx,i,&rt);
		Rectangle(hdc,rt.left,rt.top,rt.right,rt.bottom);
	}
}

void GetTrackerRect(int idx,int nTrack,RECT *trt)
{
	int tx,ty;
	RECT *ort=&arObj[idx]->rt;
	switch (nTrack) {
	case 1:
		tx=ort->left;
		ty=ort->top;
		break;
	case 2:
		tx=ort->left+(ort->right-ort->left)/2;
		ty=ort->top;
		break;
	case 3:
		tx=ort->right;
		ty=ort->top;
		break;
	case 4:
		tx=ort->left;
		ty=ort->top+(ort->bottom-ort->top)/2;
		break;
	case 5:
		tx=ort->right;
		ty=ort->top+(ort->bottom-ort->top)/2;
		break;
	case 6:
		tx=ort->left;
		ty=ort->bottom;
		break;
	case 7:
		tx=ort->left+(ort->right-ort->left)/2;
		ty=ort->bottom;
		break;
	case 8:
		tx=ort->right;
		ty=ort->bottom;
		break;
	}
	SetRect(trt,tx-TRSIZE,ty-TRSIZE,tx+TRSIZE,ty+TRSIZE);
}





LRESULT OnLButtonUp(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	if (DragMode==DM_DRAW) {
		if (AppendObject(NowTool,sx,sy,oldx,oldy)==TRUE) {
			NowSel=arNum-1;
		} else {
			NowTool=DT_SELECT;
			NowSel=-1;
		}
		InvalidateRect(hWnd,NULL,TRUE);
	}
	DragMode=DM_NONE;
	ReleaseCapture();
	return 0;
}






BOOL AppendObject(DTool Type,int x1,int y1,int x2,int y2)
{
	....
	arObj[arNum]=(DObject *)malloc(sizeof(DObject));
	arObj[arNum]->Type=Type;
	SetRect(&arObj[arNum]->rt,x1,y1,x2,y2);
	arObj[arNum]->rt.left=min(x1,x2);
	arObj[arNum]->rt.right=max(x1,x2);
	arObj[arNum]->rt.top=min(y1,y2);
	arObj[arNum]->rt.bottom=max(y1,y2);
	arNum++;
	return TRUE;
}




int FindObject(int x, int y)
{
	int idx;
	POINT pt;
	RECT trt;

	pt.x=x;
	pt.y=y;
	for (idx=arNum-1;idx>=0;idx--) {
		trt.left=min(arObj[idx]->rt.left,arObj[idx]->rt.right);
		trt.right=max(arObj[idx]->rt.left,arObj[idx]->rt.right);
		trt.top=min(arObj[idx]->rt.top,arObj[idx]->rt.bottom);
		trt.bottom=max(arObj[idx]->rt.top,arObj[idx]->rt.bottom);
		if (PtInRect(&trt,pt)==TRUE) {
			return idx;
		}
	}
	return -1;
}




#define DS_LT 0
#define DS_RT 1
#define DS_LB 2
#define DS_RB 3
....
struct DObject
{
	DTool Type;
	RECT rt;
	unsigned short Flag;
};






BOOL AppendObject(DTool Type,int x1,int y1,int x2,int y2)
{
	....
	arObj[arNum]->rt.left=min(x1,x2);
	arObj[arNum]->rt.right=max(x1,x2);
	arObj[arNum]->rt.top=min(y1,y2);
	arObj[arNum]->rt.bottom=max(y1,y2);
	if (x1<x2) {
		if (y1<y2) {
			arObj[arNum]->Flag=DS_LT;
		} else {
			arObj[arNum]->Flag=DS_LB;
		}
	} else {
		if (y1<y2) {
			arObj[arNum]->Flag=DS_RT;
		} else {
			arObj[arNum]->Flag=DS_RB;
		}
	}
	arNum++;
	return TRUE;
}






		case DT_LINE:
			if ((arObj[idx]->Flag & 0x3) == DS_LT || (arObj[idx]->Flag & 0x3) == DS_RB) {
				MoveToEx(hdc,arObj[idx]->rt.left,arObj[idx]->rt.top,NULL);
				LineTo(hdc,arObj[idx]->rt.right,arObj[idx]->rt.bottom);
			} else {
				MoveToEx(hdc,arObj[idx]->rt.left,arObj[idx]->rt.bottom,NULL);
				LineTo(hdc,arObj[idx]->rt.right,arObj[idx]->rt.top);
			}
			break;

			
			

void DelObject(int idx)
{
	free(arObj[idx]);
	memmove(arObj+idx,arObj+idx+1,(arNum-idx-1)*sizeof(DObject *));
	arNum--;
}





LRESULT OnCommand(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	switch(LOWORD(wParam)) {
	case IDM_POPUP_DELETE:
		if (NowSel != -1) {
			DelObject(NowSel);
			NowSel=-1;
			InvalidateRect(hWnd,NULL,TRUE);
		}
		break;
	}
	return 0;
}






LRESULT Main_OnCommand(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	switch(LOWORD(wParam)) {
	case IDM_FILE_EXIT:
		DestroyWindow(hWnd);
		break;
	case IDM_EDIT_DELETE:
		SendMessage(hCanvas,WM_COMMAND,MAKEWPARAM(IDM_POPUP_DELETE,0),0);
		break;





LRESULT Main_OnInitMenu(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	UINT MenuItem;
	for (MenuItem=IDM_SHAPE_SELECT;MenuItem<=IDM_SHAPE_META;MenuItem++) {
		CheckMenuItem((HMENU)wParam,MenuItem,MF_BYCOMMAND | MF_UNCHECKED);
	}
	CheckMenuItem((HMENU)wParam,IDM_SHAPE_SELECT+NowTool,MF_BYCOMMAND | MF_CHECKED);
	return 0;
}





LRESULT Main_OnInitMenu(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	CheckMenuRadioItem((HMENU)wParam,IDM_SHAPE_SELECT,IDM_SHAPE_META,
		IDM_SHAPE_SELECT+NowTool,MF_BYCOMMAND);
	return 0;
}




int APIENTRY WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance
	  ,LPSTR lpszCmdParam,int nCmdShow)
{
	....
	hWnd=CreateWindow(lpszClass,lpszClass,WS_OVERLAPPEDWINDOW,
		CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,
		NULL,(HMENU)NULL,hInstance,NULL);
	ShowWindow(hWnd,nCmdShow);
	
	HACCEL hAccel;
	hAccel=LoadAccelerators(hInstance,MAKEINTRESOURCE(IDR_ACCELERATOR1));
	while(GetMessage(&Message,0,0,0)) {
		if (!TranslateAccelerator(hWnd,hAccel,&Message)) {
			TranslateMessage(&Message);
			DispatchMessage(&Message);
		}
	}
	return (int)Message.wParam;
}




======================================
ApiDraw05
======================================



void DrawTemp(const DObject *pObj)
{
	HDC hdc;
	HPEN hPen,hOldPen;
	HBRUSH hOldBrush;

	hdc=GetDC(hCanvas);
	SetROP2(hdc,R2_XORPEN);
	hPen=CreatePen(PS_DOT,1,RGB(0,0,0));
	hOldPen=(HPEN)SelectObject(hdc,hPen);
	hOldBrush=(HBRUSH)(SelectObject(hdc,GetStockObject(NULL_BRUSH)));
	switch (pObj->Type) {
	case DT_LINE:
		if ((pObj->Flag & 0x3) == DS_LT || (pObj->Flag & 0x3) == DS_RB) {
			MoveToEx(hdc,pObj->rt.left,pObj->rt.top,NULL);
			LineTo(hdc,pObj->rt.right,pObj->rt.bottom);
		} else {
			MoveToEx(hdc,pObj->rt.left,pObj->rt.bottom,NULL);
			LineTo(hdc,pObj->rt.right,pObj->rt.top);
		}
		break;
	case DT_ELLIPSE:
		Ellipse(hdc,pObj->rt.left,pObj->rt.top,pObj->rt.right,pObj->rt.bottom);
		break;
	case DT_RECTANGLE:
		Rectangle(hdc,pObj->rt.left,pObj->rt.top,pObj->rt.right,pObj->rt.bottom);
		break;
	}
	DeleteObject(SelectObject(hdc,hOldPen));
	SelectObject(hdc,hOldBrush);
	ReleaseDC(hCanvas,hdc);
} 





LRESULT OnLButtonDown(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	int TempSel;

	if (NowTool==DT_SELECT) {
		TempSel=FindObject(LOWORD(lParam),HIWORD(lParam));
		if (NowSel != TempSel) {
			NowSel=TempSel;
			InvalidateRect(hWnd,NULL,TRUE);
			UpdateWindow(hWnd);
		}
		if (NowSel != -1) {
			oldx=LOWORD(lParam);
			oldy=HIWORD(lParam);
			dObj=*arObj[NowSel];
			DrawTemp(&dObj);
			DragMode=DM_MOVE;
		}
	} else {
	....
}





LRESULT OnMouseMove(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	....
	if (DragMode==DM_MOVE) {
		DrawTemp(&dObj);
		OffsetRect(&dObj.rt,ex-oldx,ey-oldy);
		oldx=ex;
		oldy=ey;
		DrawTemp(&dObj);
	}
	return 0;
}





LRESULT OnLButtonUp(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	....
	if (DragMode==DM_MOVE) {
		arObj[NowSel]->rt=dObj.rt;
		InvalidateRect(hWnd,NULL,TRUE);
	}
	DragMode=DM_NONE;
	ReleaseCapture();
	return 0;
}





int TrackerHitTest(int x,int y)
{
	int i;
	RECT trt;
	POINT pt;

	if (NowSel == -1) {
		return 0;
	}

	pt.x=x;
	pt.y=y;
	for (i=1;i<=8;i++) {
		GetTrackerRect(NowSel,i,&trt);
		if (PtInRect(&trt,pt) == TRUE) {
			return i;
		}
	}
	return 0;
}





LRESULT OnSetCursor(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	POINT pt;
	int nHit;

	static TCHAR *arCursor[]={0,IDC_SIZENWSE,IDC_SIZENS,IDC_SIZENESW,IDC_SIZEWE,
		IDC_SIZEWE,IDC_SIZENESW,IDC_SIZENS,IDC_SIZENWSE};

	if (NowTool == DT_SELECT) {
		GetCursorPos(&pt);
		ScreenToClient(hWnd,&pt);
		nHit=TrackerHitTest(pt.x,pt.y);
		if (nHit != 0) {
			SetCursor(LoadCursor(NULL,arCursor[nHit]));
			return TRUE;
		}
	}
	return(DefWindowProc(hWnd,WM_SETCURSOR,wParam,lParam));
}





LRESULT OnLButtonDown(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	int TempSel;
	int nHit;

	if (NowTool==DT_SELECT) {
		nHit=TrackerHitTest(LOWORD(lParam),HIWORD(lParam));
		if (nHit != 0) {
			oldx=LOWORD(lParam);
			oldy=HIWORD(lParam);
			dObj=*arObj[NowSel];
			SizeCorner=nHit;
			DrawTemp(&dObj);
			DragMode=DM_SIZE;
		} else {
			TempSel=FindObject(LOWORD(lParam),HIWORD(lParam));
			....






LRESULT OnMouseMove(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	....
	if (DragMode==DM_SIZE) {
		DrawTemp(&dObj);
		switch (SizeCorner) {
		case 1:
			dObj.rt.left+=ex-oldx;
			dObj.rt.top+=ey-oldy;
			break;
		case 2:
			dObj.rt.top+=ey-oldy;
			break;
		case 3:
			dObj.rt.right+=ex-oldx;
			dObj.rt.top+=ey-oldy;
			break;
		case 4:
			dObj.rt.left+=ex-oldx;
			break;
		case 5:
			dObj.rt.right+=ex-oldx;
			break;
		case 6:
			dObj.rt.left+=ex-oldx;
			dObj.rt.bottom+=ey-oldy;
			break;
		case 7:
			dObj.rt.bottom+=ey-oldy;
			break;
		case 8:
			dObj.rt.right+=ex-oldx;
			dObj.rt.bottom+=ey-oldy;
			break;
		}
		oldx=ex;
		oldy=ey;
		DrawTemp(&dObj);
	}
	return 0;
}






	if (DragMode==DM_SIZE) {
		DrawTemp(&dObj);
		if (SizeCorner==1 || SizeCorner==4 || SizeCorner==6) dObj.rt.left+=ex-oldx;
		if (SizeCorner==1 || SizeCorner==2 || SizeCorner==3) dObj.rt.top+=ey-oldy;
		if (SizeCorner==3 || SizeCorner==5 || SizeCorner==8) dObj.rt.right+=ex-oldx;
		if (SizeCorner==6 || SizeCorner==7 || SizeCorner==8) dObj.rt.bottom+=ey-oldy;
		oldx=ex;
		oldy=ey;
		DrawTemp(&dObj);
	}





LRESULT OnLButtonUp(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	RECT crt,irt;
	....
	if (DragMode==DM_MOVE || DragMode==DM_SIZE) {
		GetClientRect(hWnd,&crt);
		InflateRect(&crt,-10,-10);
		IntersectRect(&irt,&crt,&dObj.rt);
		if (!IsRectEmpty(&irt)) {
			arObj[NowSel]->rt=dObj.rt;
		}
		InvalidateRect(hWnd,NULL,TRUE);
	}
	DragMode=DM_NONE;
	ReleaseCapture();
	return 0;
}




void NormalizeRect(RECT *prt)
{
	int t;

	if (prt->left > prt->right) {
		t=prt->left;
		prt->left=prt->right;
		prt->right=t;
	}
	if (prt->top > prt->bottom) {
		t=prt->top;
		prt->top=prt->bottom;
		prt->bottom=t;
	}
}





int NormalizeRect(RECT *prt)
{
	int t;
	int SwapResult=0;

	if (prt->left > prt->right) {
		t=prt->left;
		prt->left=prt->right;
		prt->right=t;
		SwapResult|=1;
	}
	if (prt->top > prt->bottom) {
		t=prt->top;
		prt->top=prt->bottom;
		prt->bottom=t;
		SwapResult|=2;
	}
	return SwapResult;
}





LRESULT OnLButtonUp(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	int SwapResult;
	....
	if (DragMode==DM_MOVE || DragMode==DM_SIZE) {
		SwapResult=NormalizeRect(&dObj.rt);
		GetClientRect(hWnd,&crt);
		InflateRect(&crt,-10,-10);
		IntersectRect(&irt,&crt,&dObj.rt);
		if (!IsRectEmpty(&irt)) {
			arObj[NowSel]->rt=dObj.rt;
			if (SwapResult & 1) {
				switch (arObj[NowSel]->Flag) {
				case DS_LT:arObj[NowSel]->Flag=DS_RT;break;
				case DS_RT:arObj[NowSel]->Flag=DS_LT;break;
				case DS_LB:arObj[NowSel]->Flag=DS_RB;break;
				case DS_RB:arObj[NowSel]->Flag=DS_LB;break;
				}
			}
			if (SwapResult & 2) {
				switch (arObj[NowSel]->Flag) {
				case DS_LT:arObj[NowSel]->Flag=DS_LB;break;
				case DS_RT:arObj[NowSel]->Flag=DS_RB;break;
				case DS_LB:arObj[NowSel]->Flag=DS_LT;break;
				case DS_RB:arObj[NowSel]->Flag=DS_RT;break;
				}
			}
		}
		InvalidateRect(hWnd,NULL,TRUE);
	}




LRESULT OnKeyDown(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	BOOL bShift, bControl;
	int dx,dy;
	RECT drt,crt,irt;
	BOOL bAction=TRUE;

	if (NowSel == -1) {
		return 0;
	}
	
	bShift=((GetKeyState(VK_SHIFT) & 0x8000) != 0); 
	bControl=((GetKeyState(VK_CONTROL) & 0x8000) != 0);
	if (bControl) {
		dx=1;
		dy=1;
	} else {
		dx=8;
		dy=8;
	}
	drt=arObj[NowSel]->rt;

	if (bShift == FALSE) {
		switch(wParam) {
		case VK_LEFT:
			OffsetRect(&drt,-dx,0);
			break;
		case VK_RIGHT:
			OffsetRect(&drt,dx,0);
			break;
		case VK_UP:
			OffsetRect(&drt,0,-dy);
			break;
		case VK_DOWN:
			OffsetRect(&drt,0,dy);
			break;
		default:
			bAction=FALSE;
			break;
		}
	} else {
		switch(wParam) {
		case VK_LEFT:
			if (drt.right > drt.left + 10) {
				drt.right -= dx;
			}
			break;
		case VK_RIGHT:
			drt.right += dx;
			break;
		case VK_UP:
			if (drt.bottom > drt.top + 10) {
				drt.bottom -=dy;
			}
			break;
		case VK_DOWN:
			drt.bottom += dy;
			break;
		default:
			bAction=FALSE;
			break;
		}
	}

	if (bAction) {
		GetClientRect(hWnd,&crt);
		InflateRect(&crt,-10,-10);
		IntersectRect(&irt,&crt,&drt);
		if (!IsRectEmpty(&irt)) {
			arObj[NowSel]->rt=drt;
			InvalidateRect(hWnd,NULL,TRUE);
		}
	}
	return 0;
}





======================================
ApiDraw06
======================================


struct DObject
{
	DTool Type;
	RECT rt;
	unsigned short Flag;
	short LineWidth;
	COLORREF LineColor;
	COLORREF PlaneColor;
};





LRESULT OnCreate(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	....
	Opt.Type=(DTool)-1;
	Opt.LineWidth=3;
	Opt.LineColor=RGB(0,0,0);
	Opt.PlaneColor=RGB(0,255,0);
	return 0;
}





BOOL AppendObject(DTool Type,int x1,int y1,int x2,int y2)
{
	....
	arObj[arNum]->LineWidth=Opt.LineWidth;
	arObj[arNum]->LineColor=Opt.LineColor;
	arObj[arNum]->PlaneColor=Opt.PlaneColor;
	arNum++;
	return TRUE;
}





LRESULT OnPaint(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	HDC hdc;
	PAINTSTRUCT ps;
	int idx;
	HPEN hPen,hOldPen;
	HBRUSH hBrush,hOldBrush;

	hdc=BeginPaint(hWnd, &ps);
	for (idx=0;idx<arNum;idx++) {
		if (arObj[idx]->LineColor == (COLORREF)-1) {
			hPen=(HPEN)GetStockObject(NULL_PEN);
		} else {
			hPen=CreatePen(PS_INSIDEFRAME,arObj[idx]->LineWidth,arObj[idx]->LineColor);
		}
		hOldPen=(HPEN)SelectObject(hdc,hPen);
		if (arObj[idx]->PlaneColor == (COLORREF)-1) {
			hBrush=(HBRUSH)GetStockObject(NULL_BRUSH);
		} else {
			hBrush=CreateSolidBrush(arObj[idx]->PlaneColor);
		}
		hOldBrush=(HBRUSH)SelectObject(hdc,hBrush);
		switch (arObj[idx]->Type) {
		case DT_LINE:
			....
		}
		SelectObject(hdc,hOldPen);
		SelectObject(hdc,hOldBrush);
		if (arObj[idx]->LineColor != (COLORREF)-1) {
			DeleteObject(hPen);
		}
		if (arObj[idx]->PlaneColor != (COLORREF)-1) {
			DeleteObject(hBrush);
		}
	}
	if (NowSel != -1) {
		DrawTracker(hdc,NowSel);
	}
	EndPaint(hWnd, &ps);
	return 0;
}





COLORREF arColor[]={-1,RGB(0,0,0),RGB(255,255,255),RGB(255,0,0),RGB(0,255,0),
	RGB(0,0,255),RGB(255,255,0),RGB(255,0,255),RGB(0,255,255),RGB(64,64,64),
	RGB(128,128,128),RGB(192,192,192)};





BOOL CALLBACK PropertyDlgProc(HWND hDlg,UINT iMessage,WPARAM wParam,LPARAM lParam)
{
	static DObject *Obj;
	LPMEASUREITEMSTRUCT lpmis;
	LPDRAWITEMSTRUCT lpdis;
	HBRUSH ColorBrush, OldBrush;
	COLORREF Color;
	int i;

	switch(iMessage) {
	case WM_INITDIALOG:
		for (i=0;i<sizeof(arColor)/sizeof(arColor[0]);i++) {
			SendDlgItemMessage(hDlg,IDC_CBLINECOLOR,CB_ADDSTRING,0,(LPARAM)arColor[i]);
			SendDlgItemMessage(hDlg,IDC_CBPLANECOLOR,CB_ADDSTRING,0,(LPARAM)arColor[i]);
		}
		SendDlgItemMessage(hDlg,IDC_SPLINEWIDTH,UDM_SETRANGE,0,MAKELONG(10,0));

		Obj=(DObject *)lParam;
		SetDlgItemInt(hDlg,IDC_EDLINEWIDTH,Obj->LineWidth,FALSE);
		for (i=0;i<sizeof(arColor)/sizeof(arColor[0]);i++) {
			if (arColor[i] == Obj->LineColor) {
				break;
			}
		}
		SendDlgItemMessage(hDlg,IDC_CBLINECOLOR,CB_SETCURSEL,i,0);
		for (i=0;i<sizeof(arColor)/sizeof(arColor[0]);i++) {
			if (arColor[i] == Obj->PlaneColor) {
				break;
			}
		}
		SendDlgItemMessage(hDlg,IDC_CBPLANECOLOR,CB_SETCURSEL,i,0);
		return TRUE;
	case WM_MEASUREITEM:
		lpmis=(LPMEASUREITEMSTRUCT)lParam;
		lpmis->itemHeight=24;
		return TRUE;
	case WM_DRAWITEM:
		lpdis=(LPDRAWITEMSTRUCT)lParam;

		if (lpdis->itemState & ODS_SELECTED) {
			FillRect(lpdis->hDC, &lpdis->rcItem, GetSysColorBrush(COLOR_HIGHLIGHT));
		} else {
			FillRect(lpdis->hDC, &lpdis->rcItem, GetSysColorBrush(COLOR_WINDOW));
		}

		Color=(COLORREF)SendMessage(lpdis->hwndItem, CB_GETITEMDATA, lpdis->itemID, 0);
		if (Color == (COLORREF)-1) {
			ColorBrush=(HBRUSH)GetStockObject(NULL_BRUSH);
		} else {
			ColorBrush=CreateSolidBrush(Color);
		}
		OldBrush=(HBRUSH)SelectObject(lpdis->hDC, ColorBrush);
		Rectangle(lpdis->hDC,lpdis->rcItem.left+5,lpdis->rcItem.top+2,
			lpdis->rcItem.right-5, lpdis->rcItem.bottom-2);
		SelectObject(lpdis->hDC, OldBrush);
		if (Color == (COLORREF)-1) {
			SetTextAlign(lpdis->hDC,TA_CENTER);
			SetBkMode(lpdis->hDC,TRANSPARENT);
			TextOut(lpdis->hDC,(lpdis->rcItem.right+lpdis->rcItem.left)/2,
				lpdis->rcItem.top+4,"투명",4);
		} else {
			DeleteObject(ColorBrush);
		}
		return TRUE;
	case WM_COMMAND:
		switch (wParam) {
		case IDOK:
			Obj->LineWidth=GetDlgItemInt(hDlg,IDC_EDLINEWIDTH,NULL,FALSE);
			i=SendDlgItemMessage(hDlg,IDC_CBLINECOLOR,CB_GETCURSEL,0,0);
			Obj->LineColor=arColor[i];
			i=SendDlgItemMessage(hDlg,IDC_CBPLANECOLOR,CB_GETCURSEL,0,0);
			Obj->PlaneColor=arColor[i];
			EndDialog(hDlg,IDOK);
			return TRUE;
		case IDCANCEL:
			EndDialog(hDlg,IDCANCEL);
			return TRUE;
		}
		break;
	}
	return FALSE;
}





LRESULT Main_OnCommand(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	switch(LOWORD(wParam)) {
	....
	case IDM_SHAPE_PROPERTY:
		if (NowSel == -1) {
			DialogBoxParam(g_hInst, MAKEINTRESOURCE(IDD_PROPERTY),
				hWnd,PropertyDlgProc,(LPARAM)&Opt);
		} else {
			SendMessage(hCanvas,WM_COMMAND,MAKEWPARAM(IDM_POPUP_PROPERTY,0),0);
		}
		break;





LRESULT OnCommand(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	switch(LOWORD(wParam)) {
	....
	case IDM_POPUP_PROPERTY:
		if (NowSel != -1) {
			if (DialogBoxParam(g_hInst, MAKEINTRESOURCE(IDD_PROPERTY),
				hWnd,PropertyDlgProc,(LPARAM)arObj[NowSel])==IDOK) {
				InvalidateRect(hWnd,NULL,TRUE);
			}
		}
		break;
	}
	return 0;
}





LRESULT OnContextMenu(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	HMENU hMenu, hPopup;
	int TempSel;
	POINT pt;

	pt.x=LOWORD(lParam);
	pt.y=HIWORD(lParam);
	ScreenToClient(hWnd,&pt);
	TempSel=FindObject(pt.x,pt.y);
	if (NowSel != TempSel) {
		NowSel=TempSel;
		InvalidateRect(hWnd,NULL,TRUE);
		UpdateWindow(hWnd);
	}
	
	hMenu=LoadMenu(g_hInst, MAKEINTRESOURCE(IDR_POPUP));
	hPopup=GetSubMenu(hMenu, 0);
	if (NowSel == -1) {
		EnableMenuItem(hPopup, IDM_POPUP_DELETE, MF_BYCOMMAND | MF_GRAYED);
		EnableMenuItem(hPopup, IDM_POPUP_PROPERTY, MF_BYCOMMAND | MF_GRAYED);
	}

	TrackPopupMenu(hPopup, TPM_LEFTALIGN, LOWORD(lParam), HIWORD(lParam), 
		0, hWnd, NULL);
	DestroyMenu(hMenu);
	return 0;
}





void MoveObjectInArray(int src,int dest)
{
	DObject *tObject=arObj[src];
	size_t len;

	len=abs(src-dest)*sizeof(DObject *);
	if (src > dest) {
		memmove(arObj+dest+1,arObj+dest,len);
	} else {
		memmove(arObj+src,arObj+src+1,len);
	}
	arObj[dest]=tObject;
}





LRESULT OnCommand(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	switch(LOWORD(wParam)) {
	....
	case IDM_POPUP_FRONT:
		if (NowSel != -1 && NowSel < arNum-1) {
			MoveObjectInArray(NowSel,NowSel+1);
			NowSel=NowSel+1;
			InvalidateRect(hWnd,NULL,TRUE);
		}
		break;
	case IDM_POPUP_BACK:
		if (NowSel != -1 && NowSel > 0) {
			MoveObjectInArray(NowSel,NowSel-1);
			NowSel=NowSel-1;
			InvalidateRect(hWnd,NULL,TRUE);
		}
		break;
	case IDM_POPUP_MOSTFRONT:
		if (NowSel != -1 && NowSel < arNum-1) {
			MoveObjectInArray(NowSel,arNum-1);
			NowSel=arNum-1;
			InvalidateRect(hWnd,NULL,TRUE);
		}
		break;
	case IDM_POPUP_MOSTBACK:
		if (NowSel != -1 && NowSel > 0) {
			MoveObjectInArray(NowSel,0);
			NowSel=0;
			InvalidateRect(hWnd,NULL,TRUE);
		}
		break;
	}
	return 0;
}





LRESULT Main_OnCommand(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	switch(LOWORD(wParam)) {
	....
	case IDM_SHAPE_FRONT:
		SendMessage(hCanvas,WM_COMMAND,MAKEWPARAM(IDM_POPUP_FRONT,0),0);
		break;
	case IDM_SHAPE_BACK:
		SendMessage(hCanvas,WM_COMMAND,MAKEWPARAM(IDM_POPUP_BACK,0),0);
		break;
	case IDM_SHAPE_MOSTFRONT:
		SendMessage(hCanvas,WM_COMMAND,MAKEWPARAM(IDM_POPUP_MOSTFRONT,0),0);
		break;
	case IDM_SHAPE_MOSTBACK:
		SendMessage(hCanvas,WM_COMMAND,MAKEWPARAM(IDM_POPUP_MOSTBACK,0),0);
		break;





LRESULT OnContextMenu(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	....
	if (NowSel == -1 || NowSel >= arNum-1) {
		EnableMenuItem(hPopup, IDM_POPUP_FRONT, MF_BYCOMMAND | MF_GRAYED);
		EnableMenuItem(hPopup, IDM_POPUP_MOSTFRONT, MF_BYCOMMAND | MF_GRAYED);
	}
	if (NowSel == -1 || NowSel <= 0) {
		EnableMenuItem(hPopup, IDM_POPUP_BACK, MF_BYCOMMAND | MF_GRAYED);
		EnableMenuItem(hPopup, IDM_POPUP_MOSTBACK, MF_BYCOMMAND | MF_GRAYED);
	}

	TrackPopupMenu(hPopup, TPM_LEFTALIGN, LOWORD(lParam), HIWORD(lParam), 
		0, hWnd, NULL);
	DestroyMenu(hMenu);
	return 0;
}





LRESULT Main_OnInitMenu(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	....
	if (NowSel != -1 && NowSel < arNum-1) {
		EnableMenuItem((HMENU)wParam, IDM_SHAPE_FRONT, MF_BYCOMMAND | MF_ENABLED);
		EnableMenuItem((HMENU)wParam, IDM_SHAPE_MOSTFRONT, MF_BYCOMMAND | MF_ENABLED);
	} else {
		EnableMenuItem((HMENU)wParam, IDM_SHAPE_FRONT, MF_BYCOMMAND | MF_GRAYED);
		EnableMenuItem((HMENU)wParam, IDM_SHAPE_MOSTFRONT, MF_BYCOMMAND | MF_GRAYED);
	}
	if (NowSel != -1 && NowSel > 0) {
		EnableMenuItem((HMENU)wParam, IDM_SHAPE_BACK, MF_BYCOMMAND | MF_ENABLED);
		EnableMenuItem((HMENU)wParam, IDM_SHAPE_MOSTBACK, MF_BYCOMMAND | MF_ENABLED);
	} else {
		EnableMenuItem((HMENU)wParam, IDM_SHAPE_BACK, MF_BYCOMMAND | MF_GRAYED);
		EnableMenuItem((HMENU)wParam, IDM_SHAPE_MOSTBACK, MF_BYCOMMAND | MF_GRAYED);
	}
	return 0;
}



======================================
ApiDraw07
======================================


LRESULT OnPaint(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	HDC hdc;
	PAINTSTRUCT ps;
	int idx;
	HPEN hPen,hOldPen;
	HBRUSH hBrush,hOldBrush;
	RECT crt;
	HDC hMemDC;
	HBITMAP hOldBitmap;

	hdc=BeginPaint(hWnd, &ps);
	hMemDC=CreateCompatibleDC(hdc);
	GetClientRect(hWnd,&crt);
	if (hBackBit == NULL) {
		hBackBit=CreateCompatibleBitmap(hdc,crt.right,crt.bottom);
	}
	hOldBitmap=(HBITMAP)SelectObject(hMemDC,hBackBit);
	FillRect(hMemDC,&crt,GetSysColorBrush(COLOR_WINDOW));

	for (idx=0;idx<arNum;idx++) {
		....
	}

	BitBlt(hdc,0,0,crt.right,crt.bottom,hMemDC,0,0,SRCCOPY);
	SelectObject(hMemDC,hOldBitmap);
	DeleteDC(hMemDC);
	EndPaint(hWnd, &ps);
	return 0;
}





LRESULT OnSize(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	if (wParam != SIZE_MINIMIZED) {
		if (hBackBit) {
			DeleteObject(hBackBit);
			hBackBit=NULL;
		}
	}
	return 0;
}





LRESULT OnDestroy(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	int idx;

	for (idx=0;idx<arNum;idx++) {
		free(arObj[idx]);
	}
	free(arObj);
	if (hBackBit) {
		DeleteObject(hBackBit);
		hBackBit=NULL;
	}
	return 0;
}


======================================
ApiDraw08
======================================


int GridX, GridY;
BOOL bGrid;
int GridLineX, GridLineY;
BOOL bGridLine;




LRESULT OnCreate(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	....
	GridX=8;
	GridY=8;
	bGrid=TRUE;
	GridLineX=8;
	GridLineY=8;
	bGridLine=TRUE;




LRESULT OnPaint(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	int x,y;
	....
	FillRect(hMemDC,&crt,GetSysColorBrush(COLOR_WINDOW));

	if (bGridLine) {
		hPen=CreatePen(PS_SOLID,1,RGB(192,192,192));
		hOldPen=(HPEN)SelectObject(hMemDC,hPen);
		for (y=0;y<crt.bottom;y=y+GridLineY*GridY) {
			MoveToEx(hMemDC,0,y,NULL);
			LineTo(hMemDC,crt.right,y);
		}
		for (x=0;x<crt.right;x=x+GridLineX*GridX) {
			MoveToEx(hMemDC,x,0,NULL);
			LineTo(hMemDC,x,crt.bottom);
		}
		DeleteObject(SelectObject(hMemDC,hOldPen));
	}

	for (idx=0;idx<arNum;idx++) {
		....




void AdjustToGrid(int &x, int &y)
{
	if (bGrid) {
		x=x/GridX*GridX;
		y=y/GridY*GridY;
	}
}




BOOL CALLBACK GridDlgProc(HWND hDlg,UINT iMessage,WPARAM wParam,LPARAM lParam)
{
	switch(iMessage) {
	case WM_INITDIALOG:
		MoveToParentCenter(hDlg);
		SetDlgItemInt(hDlg,IDC_EDGRIDX,GridX,FALSE);
		SetDlgItemInt(hDlg,IDC_EDGRIDY,GridY,FALSE);
		SetDlgItemInt(hDlg,IDC_EDGRIDLINEX,GridLineX,FALSE);
		SetDlgItemInt(hDlg,IDC_EDGRIDLINEY,GridLineY,FALSE);
		if (bGrid) CheckDlgButton(hDlg,IDC_CHKGRID,BST_CHECKED);
		if (bGridLine) CheckDlgButton(hDlg,IDC_CHKGRIDLINE,BST_CHECKED);
		return TRUE;
	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDOK:
			GridX=GetDlgItemInt(hDlg,IDC_EDGRIDX,NULL,FALSE);
			GridY=GetDlgItemInt(hDlg,IDC_EDGRIDY,NULL,FALSE);
			GridLineX=GetDlgItemInt(hDlg,IDC_EDGRIDLINEX,NULL,FALSE);
			GridLineY=GetDlgItemInt(hDlg,IDC_EDGRIDLINEY,NULL,FALSE);
			bGrid=(IsDlgButtonChecked(hDlg,IDC_CHKGRID)==BST_CHECKED);
			bGridLine=(IsDlgButtonChecked(hDlg,IDC_CHKGRIDLINE)==BST_CHECKED);
			EndDialog(hDlg,IDOK);
			return TRUE;
		case IDCANCEL:
			EndDialog(hDlg,IDCANCEL);
			return TRUE;
		}
		return FALSE;
	}
	return FALSE;
}





LRESULT Main_OnCommand(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	....
	case IDM_TOOL_GRID:
		if (DialogBox(g_hInst,MAKEINTRESOURCE(IDD_GRID),hWnd,GridDlgProc)==IDOK) {
			InvalidateRect(hCanvas,NULL,FALSE);
		}
		break;





void CreateToolBar()
{
	TBBUTTON ToolBtn[]={
		{0,IDM_FILE_NEW,TBSTATE_ENABLED,TBSTYLE_BUTTON,0,0,0,0},
		{1,IDM_FILE_OPEN,TBSTATE_ENABLED,TBSTYLE_BUTTON,0,0,0,1},
		{2,IDM_FILE_SAVE,TBSTATE_ENABLED,TBSTYLE_BUTTON,0,0,0,2},
		{4,0,0,TBSTYLE_SEP,0,0},
		{3,IDM_EDIT_CUT,TBSTATE_ENABLED,TBSTYLE_BUTTON,0,0,0,3},
		{4,IDM_EDIT_COPY,TBSTATE_ENABLED,TBSTYLE_BUTTON,0,0,0,4},
		{5,IDM_EDIT_PASTE,TBSTATE_ENABLED,TBSTYLE_BUTTON,0,0,0,5},
		{4,0,0,TBSTYLE_SEP,0,0},
		{6,IDM_SHAPE_SELECT,TBSTATE_ENABLED,TBSTYLE_CHECKGROUP,0,0,0,6},
		{7,IDM_SHAPE_LINE,TBSTATE_ENABLED,TBSTYLE_CHECKGROUP,0,0,0,7},
		{8,IDM_SHAPE_ELLIPSE,TBSTATE_ENABLED,TBSTYLE_CHECKGROUP,0,0,0,8},
		{9,IDM_SHAPE_RECTANGLE,TBSTATE_ENABLED,TBSTYLE_CHECKGROUP,0,0,0,9},
		{10,IDM_SHAPE_TEXT,TBSTATE_ENABLED,TBSTYLE_CHECKGROUP,0,0,0,10},
		{11,IDM_SHAPE_BITMAP,TBSTATE_ENABLED,TBSTYLE_CHECKGROUP,0,0,0,11},
		{12,IDM_SHAPE_META,TBSTATE_ENABLED,TBSTYLE_CHECKGROUP,0,0,0,12},
		{4,0,0,TBSTYLE_SEP,0,0},
		{13,IDM_SHAPE_PROPERTY,TBSTATE_ENABLED,TBSTYLE_BUTTON,0,0,0,13},
	};
	TCHAR *szToolText="새파일\0열기\0저장\0자르기\0복사\0붙이기"
		"\0선택\0선\0원\0사각형\0텍스트\0비트맵\0메타\0속성\0";

	hToolBar=CreateToolbarEx(hWndMain, WS_CHILD | WS_VISIBLE
		| TBSTYLE_TOOLTIPS | TBSTYLE_FLAT ,
		99, 14, g_hInst, IDB_TOOLBAR, ToolBtn, 17,
		16,15,16,15,sizeof(TBBUTTON));

	SendMessage(hToolBar,TB_ADDSTRING,NULL,(LPARAM)szToolText);
	SendMessage(hToolBar,TB_AUTOSIZE,0,0);
}




LRESULT Main_OnSize(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	RECT wrt;
	int toolheight;

	if (wParam != SIZE_MINIMIZED) {
		SendMessage(hToolBar,TB_AUTOSIZE,0,0);
		GetWindowRect(hToolBar,&wrt);
		toolheight=wrt.bottom-wrt.top;
		MoveWindow(hCanvas,0,toolheight,LOWORD(lParam),HIWORD(lParam)-toolheight,TRUE);
	}
	return 0;
}





void OnIdle()
{
	static DTool OldTool=(DTool)-1;

	if (OldTool == NowTool) {
		return;
	}
	OldTool=NowTool;
	SendMessage(hToolBar,TB_SETSTATE,IDM_SHAPE_SELECT,MAKELONG(TBSTATE_ENABLED,0));
	SendMessage(hToolBar,TB_SETSTATE,IDM_SHAPE_LINE,MAKELONG(TBSTATE_ENABLED,0));
	SendMessage(hToolBar,TB_SETSTATE,IDM_SHAPE_ELLIPSE,MAKELONG(TBSTATE_ENABLED,0));
	SendMessage(hToolBar,TB_SETSTATE,IDM_SHAPE_RECTANGLE,MAKELONG(TBSTATE_ENABLED,0));
	SendMessage(hToolBar,TB_SETSTATE,IDM_SHAPE_TEXT,MAKELONG(TBSTATE_ENABLED,0));
	SendMessage(hToolBar,TB_SETSTATE,IDM_SHAPE_BITMAP,MAKELONG(TBSTATE_ENABLED,0));
	SendMessage(hToolBar,TB_SETSTATE,IDM_SHAPE_META,MAKELONG(TBSTATE_ENABLED,0));
	switch (NowTool) {
	case DT_SELECT:
		SendMessage(hToolBar,TB_SETSTATE,IDM_SHAPE_SELECT,
			MAKELONG(TBSTATE_CHECKED | TBSTATE_ENABLED,0));
		break;
	case DT_LINE:
		SendMessage(hToolBar,TB_SETSTATE,IDM_SHAPE_LINE,
			MAKELONG(TBSTATE_CHECKED | TBSTATE_ENABLED,0));
		break;
	case DT_ELLIPSE:
		SendMessage(hToolBar,TB_SETSTATE,IDM_SHAPE_ELLIPSE,
			MAKELONG(TBSTATE_CHECKED | TBSTATE_ENABLED,0));
		break;
	case DT_RECTANGLE:
		SendMessage(hToolBar,TB_SETSTATE,IDM_SHAPE_RECTANGLE,
			MAKELONG(TBSTATE_CHECKED | TBSTATE_ENABLED,0));
		break;
	case DT_TEXT:
		SendMessage(hToolBar,TB_SETSTATE,IDM_SHAPE_TEXT,
			MAKELONG(TBSTATE_CHECKED | TBSTATE_ENABLED,0));
		break;
	case DT_BITMAP:
		SendMessage(hToolBar,TB_SETSTATE,IDM_SHAPE_BITMAP,
			MAKELONG(TBSTATE_CHECKED | TBSTATE_ENABLED,0));
		break;
	case DT_META:
		SendMessage(hToolBar,TB_SETSTATE,IDM_SHAPE_META,
			MAKELONG(TBSTATE_CHECKED | TBSTATE_ENABLED,0));
		break;
	}
}





int APIENTRY WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance
	  ,LPSTR lpszCmdParam,int nCmdShow)
	....
	HACCEL hAccel;
	BOOL AllowIdle=TRUE;
	hAccel=LoadAccelerators(hInstance,MAKEINTRESOURCE(IDR_ACCELERATOR1));
	for (;;) {
		do {
			if (!GetMessage(&Message,NULL,0,0))
				goto endloop;
			if (Message.message != 0x118/*WM_SYSTIMER*/) {
				AllowIdle=TRUE;
			}
			if (!TranslateAccelerator(hWnd,hAccel,&Message)) {
				TranslateMessage(&Message);
				DispatchMessage(&Message);
			}
		} while (PeekMessage(&Message,NULL,0,0,PM_NOREMOVE));

		if (AllowIdle) {
			OnIdle();
			AllowIdle=FALSE;
		}
	}

endloop:
	return (int)Message.wParam;
}









======================================
ApiDraw09
======================================



struct DObject
{
	DTool Type;
	RECT rt;
	unsigned short Flag;
	short LineWidth;
	COLORREF LineColor;
	COLORREF PlaneColor;
	union {
		TCHAR *Text;
		BYTE *Bitmap;
		BYTE *Meta;
	};
	int Len;
	COLORREF FontColor;
	TCHAR FontFace[32];
	int FontSize;
};






LRESULT OnCreate(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	....
	Opt.LineWidth=3;
	Opt.LineColor=RGB(0,0,0);
	Opt.PlaneColor=RGB(0,255,0);
	Opt.FontColor=RGB(0,0,0);
	Opt.FontSize=10;
	lstrcpy(Opt.FontFace,"굴림");




LRESULT Main_OnCommand(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	switch(LOWORD(wParam)) {
	....
	case IDM_SHAPE_TEXT:
		NowTool=DT_TEXT;
		break;
	case IDM_SHAPE_BITMAP:
		NowTool=DT_BITMAP;
		break;
	case IDM_SHAPE_META:
		NowTool=DT_META;
		break;





void InsertBitmap(int x,int y)
{
	OPENFILENAME OFN;
	char lpstrFile[MAX_PATH]="";
	HANDLE hFile;
	DWORD FileSize, dwRead;
	BYTE *pBmp;
	BITMAPINFOHEADER *ih;

	memset(&OFN, 0, sizeof(OPENFILENAME));
	OFN.lStructSize = sizeof(OPENFILENAME);
	OFN.hwndOwner=hWndMain;
	OFN.lpstrFilter="비트맵 파일\0*.bmp\0모든 파일(*.*)\0*.*\0";
	OFN.lpstrFile=lpstrFile;
	OFN.nMaxFile=256;
	if (GetOpenFileName(&OFN)!=0) {
		hFile=CreateFile(lpstrFile,GENERIC_READ,0,NULL,
			OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
		if (hFile!=INVALID_HANDLE_VALUE) {
			FileSize=GetFileSize(hFile,NULL);
			pBmp=(BYTE *)malloc(FileSize);
			ReadFile(hFile,pBmp,FileSize,&dwRead,NULL);
			CloseHandle(hFile);
			if (*pBmp != 0x42 || *(pBmp+1) != 0x4d) {
				free(pBmp);
				return;
			}
			ih=(BITMAPINFOHEADER *)(pBmp+sizeof(BITMAPFILEHEADER));
			AppendObject(DT_BITMAP,x,y,x+ih->biWidth,y+ih->biHeight);
			arObj[arNum-1]->Bitmap=pBmp;
			arObj[arNum-1]->Len=FileSize;

			InvalidateRect(hWndMain,NULL,TRUE);
			NowTool=DT_SELECT;
			NowSel=arNum-1;
		}
	}
}






LRESULT OnLButtonDown(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	....
	if (NowTool==DT_BITMAP) {
		InsertBitmap(LOWORD(lParam),HIWORD(lParam));
		return 0;
	}





LRESULT OnPaint(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	....
	BITMAPFILEHEADER *fh;
	BITMAPINFOHEADER *ih;
	int bx,by;
	BYTE *pRaster;
	....
		case DT_BITMAP:
			fh=(BITMAPFILEHEADER *)arObj[idx]->Bitmap;
			pRaster=(PBYTE)fh+fh->bfOffBits;
			ih=(BITMAPINFOHEADER *)((PBYTE)fh+sizeof(BITMAPFILEHEADER));
			bx=ih->biWidth;
			by=ih->biHeight;
			StretchDIBits(hMemDC,arObj[idx]->rt.left,arObj[idx]->rt.top,
				arObj[idx]->rt.right-arObj[idx]->rt.left,
				arObj[idx]->rt.bottom-arObj[idx]->rt.top,0,0,bx,by,
				pRaster,(BITMAPINFO *)ih,DIB_RGB_COLORS,SRCCOPY);
			break;




void DrawTemp(const DObject *pObj)
{
	....
	case DT_RECTANGLE:
	case DT_TEXT:
	case DT_BITMAP:
	case DT_META:
		Rectangle(hdc,pObj->rt.left,pObj->rt.top,pObj->rt.right,pObj->rt.bottom);
		break;





void DelObject(int idx)
{
	if (arObj[idx]->Type >= DT_TEXT && arObj[idx]->Type <= DT_META) {
		free(arObj[idx]->Text);
	}
	free(arObj[idx]);
	memmove(arObj+idx,arObj+idx+1,(arNum-idx-1)*sizeof(DObject *));
	arNum--;
}





LRESULT OnDestroy(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	int idx;

	for (idx=0;idx<arNum;idx++) {
		if (arObj[idx]->Type >= DT_TEXT && arObj[idx]->Type <= DT_META) {
			free(arObj[idx]->Text);
		}
		free(arObj[idx]);
	}
	free(arObj);
	....






LRESULT OnPaint(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	....
	SetStretchBltMode(hMemDC,COLORONCOLOR);
	for (idx=0;idx<arNum;idx++) {
	....




int StretchMode;
....
LRESULT Main_OnCreate(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	OSVERSIONINFO osv;
	
	osv.dwOSVersionInfoSize=sizeof(OSVERSIONINFO);
	GetVersionEx(&osv);
	if (osv.dwPlatformId == VER_PLATFORM_WIN32_NT) {
		StretchMode=HALFTONE;
	} else {
		StretchMode=COLORONCOLOR;
	}
	....

LRESULT OnPaint(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	....
	SetStretchBltMode(hMemDC,StretchMode);
	for (idx=0;idx<arNum;idx++) {
	....




LRESULT OnKeyDown(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	char str[128];
	switch (wParam) {
	case VK_F1:StretchMode=BLACKONWHITE;lstrcpy(str,"BLACKONWHITE");break;
	case VK_F2:StretchMode=WHITEONBLACK;lstrcpy(str,"WHITEONBLACK");break;
	case VK_F3:StretchMode=COLORONCOLOR;lstrcpy(str,"COLORONCOLOR");break;
	case VK_F4:StretchMode=HALFTONE;lstrcpy(str,"HALFTONE");break;
	}
	SetWindowText(GetParent(hWnd),str);
	InvalidateRect(hWnd,NULL,FALSE);
	return 0;
	....





void InsertMeta(int x,int y)
{
	OPENFILENAME OFN;
	char lpstrFile[MAX_PATH]="";
	HANDLE hFile;
	DWORD FileSize, dwRead;
	BYTE *pMeta;

	memset(&OFN, 0, sizeof(OPENFILENAME));
	OFN.lStructSize = sizeof(OPENFILENAME);
	OFN.hwndOwner=hWndMain;
	OFN.lpstrFilter="메타 파일\0*.wmf\0모든 파일(*.*)\0*.*\0";
	OFN.lpstrFile=lpstrFile;
	OFN.nMaxFile=256;
	if (GetOpenFileName(&OFN)!=0) {
		hFile=CreateFile(lpstrFile,GENERIC_READ,0,NULL,
			OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
		if (hFile!=INVALID_HANDLE_VALUE) {
			FileSize=GetFileSize(hFile,NULL);
			pMeta=(BYTE *)malloc(FileSize);
			ReadFile(hFile,pMeta,FileSize,&dwRead,NULL);
			CloseHandle(hFile);
			if(*((DWORD *)pMeta) != 0x9ac6cdd7l) {
				free(pMeta);
				return;
			}
			AppendObject(DT_META,x,y,x+100,y+100);
			arObj[arNum-1]->Meta=pMeta;
			arObj[arNum-1]->Len=FileSize;

			InvalidateRect(hWndMain,NULL,TRUE);
			NowTool=DT_SELECT;
			NowSel=arNum-1;
		}
	}
}




LRESULT OnLButtonDown(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	....
	if (NowTool==DT_META) {
		InsertMeta(LOWORD(lParam),HIWORD(lParam));
		return 0;
	}



#pragma pack(push)
#pragma pack(2)
typedef struct
{
	DWORD		dwKey;
	WORD		hmf;
	SMALL_RECT	bbox;
	WORD		wInch;
	DWORD		dwReserved;
	WORD		wCheckSum;
} APMHEADER, *PAPMHEADER;
#pragma pack(pop)

void PlayPlaceableMeta(HDC hdc,BYTE *pMeta,int len,RECT *rt)
{
	HENHMETAFILE hEnh;
	PAPMHEADER pHeader=(PAPMHEADER)pMeta;
	METAFILEPICT mp;

	if(pHeader->dwKey == 0x9ac6cdd7l) {
		mp.mm = MM_ANISOTROPIC;
		mp.xExt = pHeader->bbox.Right - pHeader->bbox.Left;
		mp.xExt = ( mp.xExt * 2540l ) / (DWORD)(pHeader->wInch);
		mp.yExt = pHeader->bbox.Bottom - pHeader->bbox.Top;
		mp.yExt = ( mp.yExt * 2540l ) / (DWORD)(pHeader->wInch);
		mp.hMF = NULL;

		hEnh = SetWinMetaFileBits(len, &(pMeta[sizeof(APMHEADER)]), hdc, &mp);
		PlayEnhMetaFile(hdc,hEnh,rt);
		DeleteEnhMetaFile(hEnh);
	}
}





LRESULT OnPaint(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	....
		case DT_META:
			PlayPlaceableMeta(hMemDC,arObj[idx]->Meta,arObj[idx]->Len,&arObj[idx]->rt);
			break;





BOOL CALLBACK TextDlgProc(HWND hDlg,UINT iMessage,WPARAM wParam,LPARAM lParam)
{
	static TCHAR **ppText;
	int len;

	switch(iMessage) {
	case WM_INITDIALOG:
		ppText=(TCHAR **)lParam;
		if (*ppText) {
			SetDlgItemText(hDlg,IDC_EDSTR,*ppText);
		}
		return TRUE;
	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDOK:
			len=GetWindowTextLength(GetDlgItem(hDlg,IDC_EDSTR));
			*ppText=(TCHAR *)realloc(*ppText,len+1);
			GetDlgItemText(hDlg,IDC_EDSTR,*ppText,len+1);
			EndDialog(hDlg,IDOK);
			return TRUE;
		case IDCANCEL:
			EndDialog(hDlg,IDCANCEL);
			return TRUE;
		}
		break;
	}
	return FALSE;
}




LRESULT OnLButtonDown(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	int TempSel;
	int nHit;
	TCHAR *pText;

	if (NowTool==DT_TEXT) {
		pText=NULL;
		if (DialogBoxParam(g_hInst, MAKEINTRESOURCE(IDD_TEXT),hWnd,
			TextDlgProc,(LPARAM)&pText) == IDOK) {
			if (lstrlen(pText) == 0) {
				free(pText);
			} else {
				AppendObject(DT_TEXT,LOWORD(lParam),HIWORD(lParam),
					LOWORD(lParam)+200,HIWORD(lParam)+50);
				arObj[arNum-1]->Text=pText;
				arObj[arNum-1]->Len=lstrlen(pText)+1;
				arObj[arNum-1]->PlaneColor=-1;
				InvalidateRect(hWndMain,NULL,TRUE);
			}
			NowTool=DT_SELECT;
			NowSel=arNum-1;
		}
		return 0;
	}
	....




BOOL AppendObject(DTool Type,int x1,int y1,int x2,int y2)
{
	....
	arObj[arNum]->LineWidth=Opt.LineWidth;
	arObj[arNum]->LineColor=Opt.LineColor;
	arObj[arNum]->PlaneColor=Opt.PlaneColor;
	arObj[arNum]->FontColor=Opt.FontColor;
	arObj[arNum]->FontSize=Opt.FontSize;
	lstrcpy(arObj[arNum]->FontFace,Opt.FontFace);
	arNum++;
	return TRUE;
}




LRESULT OnPaint(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	....
	HFONT hFont,hOldFont;
	int FontHeight;

	SetBkMode(hMemDC,TRANSPARENT);
	for (idx=0;idx<arNum;idx++) {
		....
		case DT_TEXT:
			FillRect(hMemDC,&arObj[idx]->rt,hBrush);
			FontHeight=arObj[idx]->FontSize*GetDeviceCaps(hMemDC,LOGPIXELSY)/72;
			hFont=CreateFont(FontHeight,0,0,0,0,0,0,0,HANGEUL_CHARSET,3,2,1,
				VARIABLE_PITCH | FF_ROMAN,arObj[idx]->FontFace);
			hOldFont=(HFONT)SelectObject(hMemDC,hFont);
			if (arObj[idx]->FontColor != (COLORREF)-1) {
				SetTextColor(hMemDC,arObj[idx]->FontColor);
				DrawText(hMemDC,arObj[idx]->Text,-1,&arObj[idx]->rt,DT_WORDBREAK);
			}
			DeleteObject(SelectObject(hMemDC,hOldFont));
			break;




LRESULT OnLButtonDblclk(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	int TempSel;
	TCHAR *pText;

	TempSel=FindObject(LOWORD(lParam),HIWORD(lParam));
	if (TempSel == -1) {
		return 0;
	}
	if (arObj[TempSel]->Type == DT_TEXT) {
		pText=arObj[TempSel]->Text;
		if (DialogBoxParam(g_hInst, MAKEINTRESOURCE(IDD_TEXT),hWnd,
			TextDlgProc,(LPARAM)&pText) == IDOK) {
			if (lstrlen(pText) == 0) {
				DelObject(TempSel);
			} else {
				arObj[arNum-1]->Text=pText;
				arObj[arNum-1]->Len=lstrlen(pText)+1;
			}
			InvalidateRect(hWndMain,NULL,TRUE);
		}
	}
	return 0;
}




LOGFONT logfont[500];
int FontNum;




int CALLBACK EnumFamCallBack(ENUMLOGFONT FAR *lpelf, NEWTEXTMETRIC FAR *lpntm, 
							 int FontType, LPARAM lParam)
{
	if (FontNum < 500) {
		if (lpelf->elfLogFont.lfFaceName[0] != '@') {
			logfont[FontNum] = lpelf->elfLogFont;
			FontNum++;
		}
		return TRUE;
	}
	else {
		return FALSE;
	}
}

void ReEnum()
{
	HDC hdc;

	FontNum=0;
	hdc=GetDC(hWndMain);
	EnumFontFamilies(hdc, NULL, (FONTENUMPROC)EnumFamCallBack, (LPARAM)NULL);
	ReleaseDC(hWndMain, hdc);
}





BOOL CALLBACK PropertyDlgProc(HWND hDlg,UINT iMessage,WPARAM wParam,LPARAM lParam)
{
	....
	switch(iMessage) {
	case WM_INITDIALOG:
		if (FontNum==0) {
			ReEnum();
		}
		for (i=0;i<FontNum;i++) {
			SendDlgItemMessage(hDlg,IDC_CBFONTFACE,CB_ADDSTRING,0,(LPARAM)logfont[i].lfFaceName);
		}

		for (i=0;i<sizeof(arColor)/sizeof(arColor[0]);i++) {
			SendDlgItemMessage(hDlg,IDC_CBLINECOLOR,CB_ADDSTRING,0,(LPARAM)arColor[i]);
			SendDlgItemMessage(hDlg,IDC_CBPLANECOLOR,CB_ADDSTRING,0,(LPARAM)arColor[i]);
			SendDlgItemMessage(hDlg,IDC_CBFONTCOLOR,CB_ADDSTRING,0,(LPARAM)arColor[i]);
		}
		SendDlgItemMessage(hDlg,IDC_SPLINEWIDTH,UDM_SETRANGE,0,MAKELONG(10,0));

		Obj=(DObject *)lParam;
		SetDlgItemInt(hDlg,IDC_EDLINEWIDTH,Obj->LineWidth,FALSE);
		for (i=0;i<sizeof(arColor)/sizeof(arColor[0]);i++) {
			if (arColor[i] == Obj->LineColor) {
				break;
			}
		}
		SendDlgItemMessage(hDlg,IDC_CBLINECOLOR,CB_SETCURSEL,i,0);
		for (i=0;i<sizeof(arColor)/sizeof(arColor[0]);i++) {
			if (arColor[i] == Obj->PlaneColor) {
				break;
			}
		}
		SendDlgItemMessage(hDlg,IDC_CBPLANECOLOR,CB_SETCURSEL,i,0);
		SendDlgItemMessage(hDlg,IDC_SPFONTSIZE,UDM_SETRANGE,0,MAKELONG(72,6));
		SetDlgItemInt(hDlg,IDC_EDFONTSIZE,Obj->FontSize,FALSE);
		for (i=0;i<sizeof(arColor)/sizeof(arColor[0]);i++) {
			if (arColor[i] == Obj->FontColor) {
				break;
			}
		}
		SendDlgItemMessage(hDlg,IDC_CBFONTCOLOR,CB_SETCURSEL,i,0);
		for (i=0;i<FontNum;i++) {
			if (lstrcmp(logfont[i].lfFaceName,Obj->FontFace) == 0) {
				break;
			}
		}
		SendDlgItemMessage(hDlg,IDC_CBFONTFACE,CB_SETCURSEL,i,0);
		if (Obj->Type != -1) {
			if (Obj->Type != DT_TEXT) {
				EnableWindow(GetDlgItem(hDlg,IDC_EDFONTSIZE),FALSE);
				EnableWindow(GetDlgItem(hDlg,IDC_CBFONTCOLOR),FALSE);
				EnableWindow(GetDlgItem(hDlg,IDC_CBFONTFACE),FALSE);
			} else {
				EnableWindow(GetDlgItem(hDlg,IDC_EDLINEWIDTH),FALSE);
				EnableWindow(GetDlgItem(hDlg,IDC_CBLINECOLOR),FALSE);
			}
		}
		return TRUE;
	case WM_MEASUREITEM:
		....
	case WM_DRAWITEM:
		....
	case WM_COMMAND:
		switch (wParam) {
		case IDOK:
			....
			i=SendDlgItemMessage(hDlg,IDC_CBFONTCOLOR,CB_GETCURSEL,0,0);
			Obj->FontColor=arColor[i];
			Obj->FontSize=GetDlgItemInt(hDlg,IDC_EDFONTSIZE,NULL,FALSE);
			GetDlgItemText(hDlg,IDC_CBFONTFACE,Obj->FontFace,32);
			EndDialog(hDlg,IDOK);
			....





LRESULT CALLBACK WndProc(HWND hWnd,UINT iMessage,WPARAM wParam,LPARAM lParam)
{
	....
	case WM_FONTCHANGE:
		ReEnum();
		InvalidateRect(hCanvas,NULL,FALSE);
		return 0;
	}
	return(DefWindowProc(hWnd,iMessage,wParam,lParam));
}




int FindFontFromFace(TCHAR *Face)
{
	int i;

	if (FontNum == 0) {
		ReEnum();
	}
	for (i=0;i<FontNum;i++) {
		if (lstrcmp(logfont[i].lfFaceName,Face)==0) {
			return i;
		}
	}
	return -1;
}




LRESULT OnPaint(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	....
	int FontIdx;
	LOGFONT tFont;

		case DT_TEXT:
			FillRect(hMemDC,&arObj[idx]->rt,hBrush);
			FontHeight=arObj[idx]->FontSize*GetDeviceCaps(hMemDC,LOGPIXELSY)/72;
			FontIdx=FindFontFromFace(arObj[idx]->FontFace);
			if (FontIdx!=-1) {
				tFont=logfont[FontIdx];
				tFont.lfHeight=FontHeight;
				tFont.lfWidth=0;
				hFont=CreateFontIndirect(&tFont);
				hOldFont=(HFONT)SelectObject(hMemDC,hFont);
			}
			if (arObj[idx]->FontColor != (COLORREF)-1) {
				SetTextColor(hMemDC,arObj[idx]->FontColor);
				DrawText(hMemDC,arObj[idx]->Text,-1,&arObj[idx]->rt,DT_WORDBREAK);
			}
			if (FontIdx!=-1) {
				DeleteObject(SelectObject(hMemDC,hOldFont));
			}
			break;




======================================
ApiDraw09Text
======================================


사.텍스트 툴의 다른 방법
모달 대화상자를 열어서 텍스트를 편집하는 방법은 구현하기 간단하다. 모달 대화상자는 떠 있는동안 부모 윈도우가 사용 금지되므로 별다른 주의 사항도 없고 편집이 완료될 때까지 나머지 코드는 대기 상태에 있으므로 논리가 직선적이다. 그러나 사용자들은 일일이 대화상자를 열어서 편집해야 하므로 사용하기에는 대단히 불편하다. 이런 방식보다는 캔버스에서 텍스트를 바로 입력하고 편집하는 것이 통상적인 방법인데 여기서는 직접 편집을 구현해 보자.
ApiDraw09 프로젝트의 사본을 복사하여 ApiDraw09Text 프로젝트를 만든다. 단, 이 프로젝트는 이런 식으로도 텍스트를 입력받을 수 있다는 것을 테스트할 뿐이지 ApiDraw에 채택하지는 않을 예정이므로 임시 프로젝트로 실습을 진행하도록 한다. 캔버스에서 직접 텍스트를 편집하는 작업은 여러 개의 함수들이 협조적으로 동작해야 하므로 전역 변수들이 많이 필요하다. 다음 전역 변수들을 선언한다.

HWND hTextEdit;
int EditSel;
HFONT hTextEditFont;
COLORREF hTextEditColor;
int TextEditHeight;

편집에 사용할 에디트 컨트롤과 편집 대상 객체의 번호, 에디트에 설정할 폰트와 색상, 에디트의 현재 높이 등을 저장하는 변수들이다. 전역 변수가 이렇게 많이 필요하다는 것은 문제 해결 방법이 그다지 명쾌하지 못하다는 증거이기도 하다. 다음 두 함수는 텍스트 편집을 시작 및 종료한다.

void StartTextEdit(HWND hParent,int x, int y, int Sel)
{
	HDC hdc;
	TCHAR FontFace[32];
	int FontIdx;
	LOGFONT tFont;

	EditSel=Sel;
	if (EditSel != -1) {
		x=arObj[Sel]->rt.left;
		y=arObj[Sel]->rt.top;
		TextEditHeight=arObj[Sel]->FontSize;
		lstrcpy(FontFace,arObj[Sel]->FontFace);
		hTextEditColor=arObj[Sel]->FontColor;
	} else {
		TextEditHeight=Opt.FontSize;
		lstrcpy(FontFace,Opt.FontFace);
		hTextEditColor=Opt.FontColor;
	}

	hdc=GetDC(NULL);
	TextEditHeight=TextEditHeight*GetDeviceCaps(hdc,LOGPIXELSY)/72;
	ReleaseDC(NULL,hdc);

	FontIdx=FindFontFromFace(FontFace);
	if (FontIdx != -1) {
		tFont=logfont[FontIdx];
		tFont.lfHeight=TextEditHeight;
		tFont.lfWidth=0;
		hTextEditFont=CreateFontIndirect(&tFont);
	} else {
		hTextEditFont=(HFONT)GetStockObject(SYSTEM_FONT);
	}

	hTextEdit=CreateWindow("edit",NULL,WS_CHILD | WS_VISIBLE | ES_MULTILINE | ES_AUTOVSCROLL,
		x,y,300,TextEditHeight,hParent,(HMENU)10000,g_hInst,NULL);
	SendMessage(hTextEdit,WM_SETFONT,(WPARAM)hTextEditFont,MAKELONG(FALSE,0));

	if (EditSel != -1) {
		SetWindowText(hTextEdit,arObj[Sel]->Text);
		SetWindowPos(hTextEdit,HWND_TOP,0,0,arObj[Sel]->rt.right-arObj[Sel]->rt.left,
			arObj[Sel]->rt.bottom-arObj[Sel]->rt.top,SWP_NOMOVE);
	}
	SetFocus(hTextEdit);
}

void EndTextEdit()
{
	if (hTextEdit) {
		SetFocus(hCanvas);
	}
}

편집을 시작할 좌표 x, y와 편집 대상 객체의 번호 Sel을 인수로 전달받되 새로운 텍스트를 추가할 때는 Sel에 -1을 전달한다. Sel이 이미 존재하는 객체인 경우는 객체의 좌상단 좌표를 사용하고 이 객체의 글꼴 정보를 읽어오며 새로 만들어지는 텍스트 객체이면 전역 옵션으로부터 글꼴 정보를 읽으면 된다. 읽어온 글꼴 정보는 포인트 단위로 되어 있으므로 픽셀로 바꾸고 별도의 폰트가 지정되어 있을 경우 에디트 컨트롤이 사용할 글꼴을 생성해 놓는다. 텍스트 객체가 궁서 20pt로 작성되어 있다면 이 객체를 편집할 때 에디트도 설정된 글꼴 정보대로 텍스트를 출력해야 한다.
편집을 위해 캔버스의 차일드로 에디트 컨트롤을 생성하되 경계선이 없는 에디트로 만들어 마치 캔버스가 직접 편집을 하는 것처럼 보이게 한다. 이런 기법은 탐색기로 파일명을 편집할 때도 사용되는 것인데 텍스트 편집을 위해 잠시 에디트 컨트롤을 생성하는 것이다. 임시로 사용할 컨트롤이므로 ID는 10000으로 대충 지정했다. 텍스트를 생성한 후 폰트를 변경하고 이미 존재하는 객체인 경우 편집 대상 텍스트를 읽어와 에디트 컨트롤에 표시하고 에디트의 크기를 객체의 정보대로 조정한다. 마지막으로 이렇게 생성한 에디트 컨트롤에 포커스를 주면 텍스트 편집이 시작된다. 
EndTextEdit 함수는 에디트의 포커스를 회수함으로써 편집을 종료하는 함수이다. 부모 윈도우가 EN_KILLFOCUS 통지 메시지를 받았을 때 편집을 종료하는 처리를 하므로 포커스만 없애면 나머지 뒷처리는 통지 메시지가 처리한다. 텍스트 입력을 시작할 시점은 왼쪽 마우스 버튼을 누를 때이다.

LRESULT OnLButtonDown(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	....
	EndTextEdit();

	if (NowTool==DT_TEXT) {
		StartTextEdit(hWnd,LOWORD(lParam),HIWORD(lParam),-1);
		return 0;
	}
	....

DT_TEXT 툴이 선택된 경우 StartTextEdit 함수를 호출하면 편집용 에디트 컨트롤을 생성한다. 새로 텍스트 객체를 만드는 것이므로 마지막 인수는 -1이다. 텍스트 툴 상태에서 다시 클릭할 경우는 일단 편집중인 텍스트를 먼저 종료하기 위해 EndTextEdit를 호출했다. 텍스트 편집은 에디트 컨트롤이 스스로 처리하되 부모 윈도우는 에디트의 크기와 파괴 시점을 관리해야 한다. OnCommand에 다음 코드를 작성하여 에디트의 통지 메시지를 처리해야 한다. 

LRESULT OnCommand(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	int LineCount;
	RECT crt;
	int Len;
	TCHAR *Text;
	HWND hEdit;

	switch(LOWORD(wParam)) {
	case 10000:
		switch (HIWORD(wParam)) {
		case EN_CHANGE:
			LineCount=SendMessage(hTextEdit,EM_GETLINECOUNT,0,0);
			GetWindowRect(hTextEdit,&crt);
			if (LineCount*TextEditHeight > crt.bottom-crt.top) {
				crt.bottom=crt.top+LineCount*TextEditHeight;
				SetWindowPos(hTextEdit,HWND_TOP,0,0,crt.right-crt.left,
					crt.bottom-crt.top,SWP_NOMOVE);
			}
			break;
		case EN_KILLFOCUS:
			hEdit=(HWND)lParam;
			Len=GetWindowTextLength(hEdit);
			GetWindowRect(hEdit,&crt);
			ScreenToClient(GetParent(hEdit),(LPPOINT)&crt);
			ScreenToClient(GetParent(hEdit),(LPPOINT)&crt.right);
			if (EditSel == -1) {
				if (Len) {
					Text=(TCHAR *)malloc(Len+1);
					GetWindowText(hEdit,Text,Len+1);
					AppendObject(DT_TEXT,&crt);
					arObj[arNum-1]->Text=Text;
					arObj[arNum-1]->Len=Len+1;
					arObj[arNum-1]->PlaneColor=-1;
				}
				NowTool=DT_SELECT;
				NowSel=arNum-1;
			} else {
				Text=arObj[EditSel]->Text;
				Text=(TCHAR *)realloc(Text,Len+1);
				arObj[EditSel]->Len=Len+1;
				arObj[EditSel]->Text=Text;
				GetWindowText(hEdit,Text,Len+1);
				arObj[EditSel]->rt=crt;
			}
			DestroyWindow(hEdit);
			hTextEdit=NULL;
			DeleteObject(hTextEditFont);
			break;
		}
		break;
	....

캔버스는 에디트로부터 전달되는 두 개의 통지 메시지를 처리하는데 우선 EN_CHANGE를 받았을 때 에디트가 몇 줄의 텍스트를 가지고 있는지 조사하여 지금 높이보다 더 많은 줄을 가지게 되었으면 에디트의 높이를 확장한다. 캔버스가 직접 편집하는 것처럼 보이도록 하고 싶은데 여기에 스크롤 바가 나타난다거나 일부 텍스트가 숨어 버리면 보기 좋지 않으므로 에디트를 편집 텍스트의 크기에 맞게 늘리도록 했다.
에디트의 높이를 관리하는 코드이므로 엔터키가 입력될 때마다 한 줄씩 늘리면 될 것 같지만 그것보다는 조금 더 복잡하다. 왜냐하면 명시적인 개행 입력외에 줄이 에디트의 오른쪽 끝에 닿아서 자동 개행되는 경우도 있기 때문이다. 그래서 텍스트가 바뀔 때마다 줄 수를 세 보고 폰트 높이를 곱해 현재 에디트 높이가 적절한지를 점검했다. 텍스트를 삭제할 때는 에디트의 높이를 줄일 수도 있지만 사용자가 객체의 크기를 미리 크게 만들어 놓고 편집을 시작할 수도 있으므로 이 처리는 하지 않았다.
다음은 EN_KILLFOCUS 통지 메시지를 처리하는데 에디트가 포커스를 잃을 때를 편집 완료 시점으로 인식한다. 이 통지 메시지를 받았을 때 텍스트 객체를 새로 만들거나 아니면 기존 객체의 텍스트를 새로 편집된 내용으로 변경한다. 임시로 만든 에디트는 포커스를 잃으면 더 이상 존재할 필요가 없으므로 파괴시키고 에디트가 사용하던 폰트도 해제하였다. 다음 코드는 에디트의 색상을 관리한다. 

LRESULT CALLBACK CanvasProc(HWND hWnd,UINT iMessage,WPARAM wParam,LPARAM lParam)
{
	....
	case WM_CTLCOLOREDIT:
		if ((HWND)lParam == hTextEdit) {
			DefWindowProc(hWnd,WM_CTLCOLOREDIT,wParam,lParam);
			SetTextColor((HDC)wParam,hTextEditColor);
			return TRUE;
		}
		return 0;
	}
	return(DefWindowProc(hWnd,iMessage,wParam,lParam));
}

에디트는 자신의 색상 결정을 위해 보무 윈도우에게 WM_CTLCOLOREDIT 메시지를 보내는데 이 메시지에서 에디트의 텍스트 색상을 변경할 수 있다. 면의 색상까지는 관리할 필요없이 글자의 색상만 관리하도록 했다. 텍스트 편집중에 다른 툴을 선택할 때도 편집을 즉시 종료해야 하며 기타 텍스트 편집 이외의 동작을 하면 즉시 종료하는 것이 좋다. 

LRESULT Main_OnCommand(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	EndTextEdit();
	....

메인 메뉴의 특정 메뉴를 선택하면 텍스트 편집을 즉시 중지하도록 했다. 텍스트 객체를 더블클릭하면 기존 객체를 편집한다. 이때는 StartTextEdit함수를 호출하되 선택된 객체의 번호를 넘겨 이 객체에 대한 에디트를 생성하도록 했다.

LRESULT OnLButtonDblclk(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	int TempSel;

	TempSel=FindObject(LOWORD(lParam),HIWORD(lParam));
	if (TempSel == -1) {
		return 0;
	}
	if (arObj[TempSel]->Type == DT_TEXT) {
		StartTextEdit(hWnd,LOWORD(lParam),HIWORD(lParam),TempSel);
	}
	return 0;
}

이상으로 캔버스에서 직접 편집하는 코드를 작성해 보았는데 잘 동작하는 것 같지만 사실 그다지 정확한 코드는 아니다. 편집을 종료하는 시점을 잡기가 굉장히 어려운데 이런 코드는 지속적인 관리가 필요해서 유지 비용이 높은 편이다. 기능을 확장할 때마다 이 부분이 계속 말썽을 부릴 위험이 있다. 또한 현재 구현된 기능도 완벽하지 않은데 원래 이런 편집중에 Esc키를 누르면 즉시 편집을 종료하든가 취소해야 한다. 에디트가 포커스를 가진 상태에서 이 키 입력을 부모가 알 수는 없기 때문에 이를 처리하려면 서브클래싱이 필요하다. 지금보다 더 복잡해져야 한다는 얘기다.
조금 더 코드를 섬세하게 다듬으면 직접 편집하는 기능을 완벽하게 구현하는 것이 가능하기는 하겠지만 예측되는 것보다 훨씬 다량의 코드가 작성되어야 한다. 게다가 버그도 조금 보이는데 더블클릭해서 재편집할 때 트래커의 일부가 지워지지 않는 문제가 있다. 물론 문제를 발견했으면 해결해야 하고 이 역시나 개발자의 노력을 요구한다. 이는 이 실습의 목표와 부합되지 않아 학습자를 지치게 만드는 요인이 되기에 충분하다. 그래서 이 실습에서는 이 방법을 채택하지 않고 모달 대화상자로 텍스트를 편집하는 방법을 계속 사용하기로 한다.



======================================
ApiDraw10
======================================


TCHAR NowFile[MAX_PATH];
BOOL bModified;





void ChangeCaption(TCHAR *Path)
{
	TCHAR Cap[MAX_PATH+64];

	lstrcpy(NowFile,Path);
	wsprintf(Cap,"ApiDraw - %s",Path);
	SetWindowText(hWndMain,Cap);
}




LRESULT OnCreate(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	....
	ChangeCaption("이름없음");
	bModified=FALSE;
	return 0;
}





void InitDoc()
{
	arSize=100;
	arNum=0;
	arGrowBy=50;
	arObj=(DObject **)malloc(sizeof(DObject *)*arSize);
	NowSel=-1;
	ChangeCaption("이름없음");
	bModified=FALSE;
}

void FreeDoc()
{
	int idx;

	for (idx=0;idx<arNum;idx++) {
		if (arObj[idx]->Type >= DT_TEXT && arObj[idx]->Type <= DT_META) {
			free(arObj[idx]->Text);
		}
		free(arObj[idx]);
	}
	free(arObj);
}




int ConfirmSave()
{
	int result=IDNO;
	TCHAR Mes[MAX_PATH+64];

	if (bModified) {
		wsprintf(Mes,"%s 파일이 변경되었습니다. 저장하시겠습니까?",NowFile);
		result=MessageBox(hWndMain,Mes,"알림",MB_YESNOCANCEL);
		if (result == IDCANCEL) {
			return IDCANCEL;
		}
		if (result == IDYES) {
			if (Save() == FALSE)
				return IDCANCEL;
			else 
				return IDYES;
		}
	}
	return result;
}





void New()
{
	if (ConfirmSave() == IDCANCEL) {
		return;
	}
	FreeDoc();
	InitDoc();
	InvalidateRect(hWndMain,NULL,TRUE);
}




struct FileHeader
{
	TCHAR szHeader[32];
	int version;
	int arNum;
};





BOOL Save()
{
	if (lstrcmp(NowFile,"이름없음")==0) {
		return SaveAs();
	} else {
		return SaveToFile(NowFile);
	}
}

BOOL SaveAs()
{
	OPENFILENAME OFN;
	TCHAR lpstrFile[MAX_PATH]="";

	memset(&OFN, 0, sizeof(OPENFILENAME));
	OFN.lStructSize = sizeof(OPENFILENAME);
	OFN.hwndOwner=hWndMain;
	OFN.lpstrFilter="ApiDrawFile(*.adr)\0*.adr\0Every File(*.*)\0*.*\0";
	OFN.lpstrFile=lpstrFile;
	OFN.nMaxFile=256;
	OFN.lpstrDefExt="adr";
	if (GetSaveFileName(&OFN)==FALSE) {
		return FALSE;
	}
	ChangeCaption(OFN.lpstrFile);
	return SaveToFile(NowFile);
}

BOOL SaveToFile(TCHAR *Path)
{
	FileHeader Header;
	HANDLE hFile;
	DWORD dwWritten;
	int idx;

	hFile=CreateFile(Path,GENERIC_WRITE,0,NULL,
		CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
	if (hFile==INVALID_HANDLE_VALUE) {
		return FALSE;
	}

	strcpy(Header.szHeader,"ApiDraw File");
	Header.version=100;
	Header.arNum=arNum;
	WriteFile(hFile,&Header,sizeof(Header),&dwWritten,NULL);

	for (idx=0;idx<arNum;idx++) {
		WriteFile(hFile,arObj[idx],sizeof(DObject),&dwWritten,NULL);
		if (arObj[idx]->Type >= DT_TEXT && arObj[idx]->Type <= DT_META) {
			WriteFile(hFile,arObj[idx]->Text,arObj[idx]->Len,&dwWritten,NULL);
		}
	}

	CloseHandle(hFile);
	bModified=FALSE;
	return TRUE;
}




void Open()
{
	FileHeader Header;
	OPENFILENAME OFN;
	TCHAR lpstrFile[MAX_PATH]="";
	HANDLE hFile;
	DWORD dwRead;
	int idx;

	if (ConfirmSave() == IDCANCEL) {
		return;
	}
	memset(&OFN, 0, sizeof(OPENFILENAME));
	OFN.lStructSize = sizeof(OPENFILENAME);
	OFN.hwndOwner=hWndMain;
	OFN.lpstrFilter="ApiDrawFile(*.adr)\0*.adr\0Every File(*.*)\0*.*\0";
	OFN.lpstrFile=lpstrFile;
	OFN.nMaxFile=256;
	OFN.lpstrDefExt="adr";
	if (GetOpenFileName(&OFN)==FALSE) {
		return;
	}

	hFile=CreateFile(OFN.lpstrFile,GENERIC_READ,0,NULL,
		OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
	if (hFile==INVALID_HANDLE_VALUE) {
		MessageBox(hWndMain,"파일을 열 수 없습니다.","에러",MB_OK);
		return;
	}

	ReadFile(hFile,&Header,sizeof(Header),&dwRead,NULL);
	if (strcmp(Header.szHeader,"ApiDraw File") != 0) {
		MessageBox(hWndMain,"ApiDraw 파일이 아닙니다.","에러",MB_OK);
		CloseHandle(hFile);
		return;
	}
	if (Header.version != 100) {
		MessageBox(hWndMain,"버전이 1.0이 아닙니다.","에러",MB_OK);
		CloseHandle(hFile);
		return;
	}

	FreeDoc();
	InitDoc();

	arNum=Header.arNum;
	if (arNum >= arSize) {
		arSize=arNum+arGrowBy;
		arObj=(DObject **)realloc(arObj,sizeof(DObject *)*arSize);
	}
	for (idx=0;idx<arNum;idx++) {
		arObj[idx]=(DObject *)malloc(sizeof(DObject));
		ReadFile(hFile,arObj[idx],sizeof(DObject),&dwRead,NULL);
		if (arObj[idx]->Type >= DT_TEXT && arObj[idx]->Type <= DT_META) {
			arObj[idx]->Text=(TCHAR *)malloc(arObj[idx]->Len);
			ReadFile(hFile,arObj[idx]->Text,arObj[idx]->Len,&dwRead,NULL);
		}
	}
	CloseHandle(hFile);
	InvalidateRect(hWndMain,NULL,TRUE);
	ChangeCaption(OFN.lpstrFile);
}





LRESULT Main_OnCommand(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	switch(LOWORD(wParam)) {
	case IDM_FILE_NEW:
		New();
		break;
	case IDM_FILE_OPEN:
		Open();
		break;
	case IDM_FILE_SAVE:
		Save();
		break;
	case IDM_FILE_SAVEAS:
		SaveAs();
		break;
	....




LRESULT CALLBACK WndProc(HWND hWnd,UINT iMessage,WPARAM wParam,LPARAM lParam)
{
....
#ifndef _DEBUG
	case WM_QUERYENDSESSION:
	case WM_CLOSE:
		if (ConfirmSave() == IDCANCEL) {
			return TRUE;
		} else {
			break;
		}
#endif
	}
	return(DefWindowProc(hWnd,iMessage,wParam,lParam));
}






======================================
ApiDraw11
======================================


UINT ClipFormat;
int PasteX, PasteY;






LRESULT Main_OnCreate(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	....
	ClipFormat=RegisterClipboardFormat("ApiDraw1.0_ClipboardFormat_"
		"RegisteredBy_KoreaKimSangHyung_When_20041108_03:58:12");
	return 0;
}





void Copy()
{
	HGLOBAL hmem;
	int size;
	BYTE *ptr;
	
	if (NowSel == -1) {
		return;
	}
	size=sizeof(DObject);
	if (arObj[NowSel]->Type >= DT_TEXT && arObj[NowSel]->Type <= DT_META) {
		size += arObj[NowSel]->Len;
	}

	hmem=GlobalAlloc(GHND,size);
	ptr=(BYTE *)GlobalLock(hmem);
	memcpy(ptr,arObj[NowSel],sizeof(DObject));
	if (arObj[NowSel]->Type >= DT_TEXT && arObj[NowSel]->Type <= DT_META) {
		memcpy(ptr+sizeof(DObject),arObj[NowSel]->Text,arObj[NowSel]->Len);
	}
	GlobalUnlock(hmem);
	if (OpenClipboard(hWndMain)) {
		EmptyClipboard();
		SetClipboardData(ClipFormat,hmem);
		CloseClipboard();
		PasteX=arObj[NowSel]->rt.left+16;
		PasteY=arObj[NowSel]->rt.top+16;
	}
}




void Paste()
{
	HGLOBAL hmem;
	DObject *pNew;
	RECT nrt;

	if (IsClipboardFormatAvailable(ClipFormat)) {
		OpenClipboard(hWndMain);
		hmem=GetClipboardData(ClipFormat);
		pNew=(DObject *)GlobalLock(hmem);
		nrt.left=PasteX;
		nrt.top=PasteY;
		nrt.right=nrt.left+pNew->rt.right-pNew->rt.left;
		nrt.bottom=nrt.top+pNew->rt.bottom-pNew->rt.top;
		PasteX+=16;
		PasteY+=16;
		AppendObject(pNew->Type,&nrt);
		arObj[arNum-1]->LineWidth=pNew->LineWidth;
		arObj[arNum-1]->LineColor=pNew->LineColor;
		arObj[arNum-1]->PlaneColor=pNew->PlaneColor;
		arObj[arNum-1]->Len=pNew->Len;
		arObj[arNum-1]->FontSize=pNew->FontSize;
		arObj[arNum-1]->FontColor=pNew->FontColor;
		lstrcpy(arObj[arNum-1]->FontFace,pNew->FontFace);

		if (pNew->Type >= DT_TEXT && pNew->Type <= DT_META) {
			arObj[arNum-1]->Text=(TCHAR *)malloc(pNew->Len);
			memcpy(arObj[arNum-1]->Text,(BYTE *)pNew+sizeof(DObject),pNew->Len);
		}
		GlobalUnlock(hmem);
		CloseClipboard();
		NowSel=arNum-1;
		InvalidateRect(hWndMain,NULL,TRUE);
	}
}




LRESULT Main_OnCommand(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	....
	case IDM_EDIT_CUT:
		Copy();
		SendMessage(hCanvas,WM_COMMAND,MAKEWPARAM(IDM_POPUP_DELETE,0),0);
		break;
	case IDM_EDIT_COPY:
		Copy();
		break;
	case IDM_EDIT_PASTE:
		Paste();
		break;





LRESULT Main_OnInitMenu(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	....
	if (NowSel == -1) {
		EnableMenuItem((HMENU)wParam, IDM_EDIT_CUT, MF_BYCOMMAND | MF_GRAYED);
		EnableMenuItem((HMENU)wParam, IDM_EDIT_COPY, MF_BYCOMMAND | MF_GRAYED);
	} else {
		EnableMenuItem((HMENU)wParam, IDM_EDIT_CUT, MF_BYCOMMAND | MF_ENABLED);
		EnableMenuItem((HMENU)wParam, IDM_EDIT_COPY, MF_BYCOMMAND | MF_ENABLED);
	}
	if (IsClipboardFormatAvailable(ClipFormat)) {
		EnableMenuItem((HMENU)wParam, IDM_EDIT_PASTE, MF_BYCOMMAND | MF_ENABLED);
	} else {
		EnableMenuItem((HMENU)wParam, IDM_EDIT_PASTE, MF_BYCOMMAND | MF_GRAYED);
	}
	return 0;
}





void OnIdle()
{
	static DTool OldTool=(DTool)-1;

	if (NowSel == -1) {
		SendMessage(hToolBar,TB_SETSTATE,IDM_EDIT_CUT,MAKELONG(0,0));
		SendMessage(hToolBar,TB_SETSTATE,IDM_EDIT_COPY,MAKELONG(0,0));
	} else {
		SendMessage(hToolBar,TB_SETSTATE,IDM_EDIT_CUT,MAKELONG(TBSTATE_ENABLED,0));
		SendMessage(hToolBar,TB_SETSTATE,IDM_EDIT_COPY,MAKELONG(TBSTATE_ENABLED,0));
	}
	if (IsClipboardFormatAvailable(ClipFormat)) {
		SendMessage(hToolBar,TB_SETSTATE,IDM_EDIT_PASTE,MAKELONG(TBSTATE_ENABLED,0));
	} else {
		SendMessage(hToolBar,TB_SETSTATE,IDM_EDIT_PASTE,MAKELONG(0,0));
	}

	if (OldTool == NowTool) {
		return;
	}




LRESULT Main_OnCommand(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	....
	case IDM_HELP_ABOUT:
		MessageBox(hWnd,"C언어와 API 실습을 위한 예제 ApiDraw입니다.\n"
			"이 예제의 소스와 설명 문서는 http://www.winapi.co.kr에 있습니다.",
			"프로그램 소개",MB_OK);
		break;





void MoveToParentCenter(HWND hWnd)
{
	RECT wrt,crt;
	HWND hParent;

	hParent=GetParent(hWnd);
	if (IsIconic(hParent)) {
		ShowWindow(hParent,SW_RESTORE);
	}

	GetWindowRect(hParent,&wrt);
	GetWindowRect(hWnd,&crt);
	SetWindowPos(hWnd,HWND_NOTOPMOST,wrt.left+(wrt.right-wrt.left)/2-(crt.right-crt.left)/2,
		wrt.top+(wrt.bottom-wrt.top)/2-(crt.bottom-crt.top)/2,0,0,SWP_NOSIZE);
}




BOOL CALLBACK GridDlgProc(HWND hDlg,UINT iMessage,WPARAM wParam,LPARAM lParam)
{
	switch(iMessage) {
	case WM_INITDIALOG:
		MoveToParentCenter(hDlg);
		....





void GetTrackerRect(int idx,int nTrack,RECT *trt)
{
	....
	if (arObj[idx]->Type == DT_LINE) {
		if ((arObj[idx]->Flag & 03) == DS_LT || (arObj[idx]->Flag & 03) == DS_RB) {
			if (nTrack != 1 && nTrack != 8) {
				SetRect(trt,0,0,0,0);
			}
		}
		if ((arObj[idx]->Flag & 03) == DS_RT || (arObj[idx]->Flag & 03) == DS_LB) {
			if (nTrack != 3 && nTrack != 6) {
				SetRect(trt,0,0,0,0);
			}
		}
	}
}





struct ddapack {
	int x,y;
	int offset;
};
void CALLBACK lineproc(int x,int y,LPARAM lParam)
{
	ddapack *pack=(ddapack *)lParam;
	int offset;

	offset=(int)hypot(x-pack->x,y-pack->y);
	pack->offset=min(pack->offset,offset);
}

int FindObject(int x, int y)
{
	int idx;
	POINT pt;
	HRGN hRgn;
	BOOL bIn;
	ddapack pack;
	RECT temprt;

	pt.x=x;
	pt.y=y;
	for (idx=arNum-1;idx>=0;idx--) {
		temprt=arObj[idx]->rt;
		InflateRect(&temprt,3,3);
		if (PtInRect(&temprt,pt)==TRUE) {
			switch (arObj[idx]->Type) {
			case DT_LINE:
				pack.x=x;
				pack.y=y;
				pack.offset=100;
				if ((arObj[idx]->Flag & 03) == DS_LT || (arObj[idx]->Flag & 03) == DS_RB) {
					LineDDA(arObj[idx]->rt.left, arObj[idx]->rt.top,arObj[idx]->rt.right,
						arObj[idx]->rt.bottom,lineproc,(LPARAM)&pack);
				} else {
					LineDDA(arObj[idx]->rt.right, arObj[idx]->rt.top,arObj[idx]->rt.left,
						arObj[idx]->rt.bottom,lineproc,(LPARAM)&pack);
				}
				if (pack.offset <= 4) {
					return idx;
				}
				break;
			case DT_ELLIPSE:
				hRgn=CreateEllipticRgn(arObj[idx]->rt.left, arObj[idx]->rt.top,
					arObj[idx]->rt.right,arObj[idx]->rt.bottom);
				bIn=PtInRegion(hRgn,x,y);
				DeleteObject(hRgn);
				if (bIn) return idx;
				break;
			default:
				if (PtInRect(&arObj[idx]->rt,pt)==TRUE) {
					return idx;
				}
				break;
			}
		}
	}
	return -1;
}





BOOL IsValidObject(HWND hCanvas,int Type, RECT *ort)
{
	RECT crt,irt;
	HRGN hRgn;
	BOOL bIn;

	GetClientRect(hCanvas,&crt);
	InflateRect(&crt,-10,-10);
	switch (Type) {
	case DT_LINE:
		if (ort->left == ort->right && ort->top == ort->bottom)
			return FALSE;
		return (PtInRect(&crt,*((POINT *)ort)) || PtInRect(&crt,*((POINT *)&ort->right)));
	case DT_ELLIPSE:
		if (IsRectEmpty(ort))
			return FALSE;
		hRgn=CreateEllipticRgn(ort->left, ort->top, ort->right,ort->bottom);
		bIn=RectInRegion(hRgn,&crt);
		DeleteObject(hRgn);
		return bIn;
	default:
		IntersectRect(&irt,&crt,ort);
		return (!IsRectEmpty(&irt));
	}
}





LRESULT OnLButtonUp(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	....
	if (DragMode==DM_MOVE || DragMode==DM_SIZE) {
		SwapResult=NormalizeRect(&dObj.rt);
		if (IsValidObject(hWnd,arObj[NowSel]->Type,&dObj.rt)) {

LRESULT OnKeyDown(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	....
	if (bAction) {
		if (IsValidObject(hWnd,arObj[NowSel]->Type,&drt)) {
			bModified=TRUE;
			arObj[NowSel]->rt=drt;
			InvalidateRect(hWnd,NULL,TRUE);
		}
	}







LRESULT OnKeyDown(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	BOOL bShift, bControl;
	int dx,dy;
	RECT drt;
	BOOL bAction=TRUE;

	if (DragMode != DM_NONE) {
		return 0;
	}
	....

LRESULT OnContextMenu(HWND hWnd,WPARAM wParam,LPARAM lParam)
{
	HMENU hMenu, hPopup;
	int TempSel;
	POINT pt;

	if (DragMode != DM_NONE) {
		return 0;
	}
	....


